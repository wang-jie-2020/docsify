## adapter

适配模式,指的是新的接口通过适配器访问原有接口,保持尽可能少的修改变更.

业务场景中很少尝试,原因是大多数情况对api的调用封装只会考虑到一层,例如以api包装或者helper处理,但实际上这两类方式不一定完全符合设计约束,或者说基本不符合程序设计思路

可参考的实例是基于autofac-castle-dynamicProxy的castle-core-asyncInterceptor的abp封装,这里主要梳理逻辑而不是代码示例.

按示例代码逻辑梳理出来的调用过程:

1. adapter 入口

   继承或实现组件接口,实现泛型注入(通常为构造函数继承重写)

2. adapter 调用

   在入口组件中对核心调用过程重构.通过1个或多个适配器组织参数或者方法调用,同时注入自己的逻辑处理和自己的逻辑参数,替换或者追加

3. adapter 参数

   如非必要,简单类型参数还是尽量包装,非简单类型的参数还是通过适配过程更合适

   在适配过程中甚至可以插入新的代码逻辑函数委托



最终过程是以原组件注册-触发->进入重写的入口实现->进入adapter中的新逻辑和方法,同时传递原接口必要信息->调用adapter方法



## hash和md5

哈希算法也称摘要算法、散列算法，哈希函数的输入为一段**可变长度x**，输出一**固定长度串**，该串被称为**x的哈希值**。Hash函数满足以下几个基本需求：  

（1）输入值x为任意长度 

（2）输出值长度固定  

（3）单向函数，算法不可逆  

（4）唯一性，很难找到两个不同的输入会得到相同的Hash输出值

md5是hashlib模块里的一个方法，是用来做加密算法的，注意他是不能解密的。



## Nginx之Forward头

http规范里对请求头的定义、兼容废弃等标志的很清楚, 按需再查吧.

这里针对的是经过Nginx转发之后的Scheme、Host等进行标识和转存, NetCore中已有相关集成

    proxy_set_header X-Forwarded-Host $the_host/onlyoffice;
    proxy_set_header X-Forwarded-Proto $the_scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;



## signalR底板

底板针对的也就是连接数量太多增加了集群负载均衡之后进行的多server同步发送，但似乎有点难以处理逻辑（指的是由自主控制的）


一种比较简单的做法是客户端直连数据中间件，比如MQ、Redis...

通常的demo中都是混合api和hub的，通信通过HubContext，这种方式似乎耦合性高而且也很难继续优化，提供的如redis底板方案最终的落地还是要考虑负载均衡

如果将hub-server从逻辑中拿走，可能效果更好，思路大概如下：

1. 客户端http请求api-server，得到hub-server的url，通过某种算法持久

2. 客户端连接hub-server，持久化连接

3. api-server通过httpClient请求hub-server，传输消息

4. hub-server向客户端输出

   

## C# 使用PYTHON

1. C++的动态库链接(套个中间层)

2. IronPython   

   https://github.com/IronLanguages/ironpython3

   https://github.com/IronLanguages/ironpython3/blob/master/Documentation/package-compatibility.md

3. Pythonnet

   https://github.com/pythonnet/pythonnet



## C# TransactionScope

select for update

select with tablelock

select with nolock

```csharp
 using (var scope = new TransactionScope(TransactionScopeOption.Suppress)) {}

 using (var scope = new TransactionScope(
     TransactionScopeOption.Required, 
     new TransactionOptions { IsolationLevel = IsolationLevel.ReadUncommitted })) {}
```



## C# WCF

以往基本都是单工模式, 偶然遇到了双工模式的例子, 服务端提供了ServiceContract和CallBackContract, 客户端实现了CallBackContract



## C# 中的postgreSQL 驱动

(1) 在ORACLE迁移OPENGAUSS时，NVARCHAR2的类型同样迁移，但OPENGAUSS使用的是PGSQL的连接库，而PGSQL中是不存在此类型的。

在JAVA中，通过JDBC正常可以通过查询语句得到ResultSet，而在Net中，报错‘System.Object’‘nvarchar2’....

https://stackoverflow.com/questions/24014147/how-to-convert-string-to-unicode-using-postgresql/24015093#24015093



(2) Npgsql 9.0版本, 连接数据库第一次失败,第二次成功(造成大量定时任务失败)

问题表现有些类似于: https://github.com/npgsql/npgsql/issues/6274

解决方式:(1) 还原到5版本(issue中说从6有问题) (2) 仍旧使用9,但是在连接字符串中增加'SSL Mode=Disable'



## C# URI和URL编码：EscapeDataString、EscapeUriString和UrlEncode

`Uri.EscapeDataString`

​	用于对URI的数据部分进行编码,将所有非字母数字字符（包括空格）转换为其百分号编码形式

​	和JS中的`encodeURIComponent`一致

`Uri.EscapeUriString`

​	对整个URI进行编码,保留URI中的保留字符（如`?`、`/`、`#`等），不对它们进行编码

​	**和浏览器行为一致,但它被标记为弃用了**

​	和JS中的`encodeURI`一致



encodeURIComponent(proxy.$base64.encode(encodeURI(row.fileUrl)));



## aspnet 自包含部署

[.NET CLI 发布 .NET 应用](https://learn.microsoft.com/zh-cn/dotnet/core/deploying/deploy-with-cli)

```bash
dotnet publish -c Release -r win10-x64 -o %outPut% --self-contained true

dotnet publish -c Release -r linux-x64 --self-contained true
```



## aspnet 在Linux中的问题

System.Drawing验证码The type initializer for 'Gdip' threw an exception.

Linux部署时由于System.Drawing.Common的路线问题会出现如上错误，这个错误的官方释疑：

https://learn.microsoft.com/zh-cn/dotnet/core/compatibility/core-libraries/6.0/system-drawing-common-windows-only

补充阅读 https://devblogs.microsoft.com/dotnet/net-core-image-processing/

目前可以查询到有些包依赖于此，比如EPPlus的较旧版本。



目前比较合适的nuget：https://gitee.com/pojianbing/lazy-captcha

imageSharp许可证有问题，SkiaSharp也许是最合适目前的（在Linux上可能需要再依赖于官方提供的其他依赖）



## aspnet jwt莫名错误--userid写在'sub'字段,认证中间件失效

sub 字段作为唯一标识符在各个方面都没有问题,,,微软为什么要强制mapping很长一串的标准值而不是直接的字符 ???



## aspnet ApiController标注--自动模型验证且不经过模型绑定检查

如题,这种问题有点二.

see https://learn.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-9.0#apicontroller-attribute

see https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.apibehavioroptions?view=aspnetcore-9.0



## aspnet 请求处理管道图

![img](https://raw.gitcode.com/qq_36179938/images/raw/main/900440-20230430112047263-366313603.png)



## node包依赖 npm install

```bash
npm install --registry=https://registry.npm.taobao.org
npm install --registry=https://registry.npmmirror.com
```

## node版本管理 volta

```bash
curl https://get.volta.sh | bash

volta install node@22.5.1
volta install node

volta pin node@20.16
```

## ide webstorm 点击import跳转

在项目根目录下[文件：jsconfig.json]

```js
{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  },
  "exclude": [
    "node_modules",
    "dist"
  ]
}

```



## Jar

```bash
@echo off
echo.
echo [信息] 使用Jar命令运行Gateway工程。
echo.

cd %~dp0
cd ../ruoyi-gateway/target

set JAVA_OPTS=-Xms512m -Xmx1024m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m

java -Dfile.encoding=utf-8 %JAVA_OPTS% -jar ruoyi-gateway.jar

cd bin
pause
```

-Xms分配堆最小内存，默认为物理内存的1/64；-Xmx分配最大内存，默认为物理内存的1/4。
非堆内存分配用-XX:PermSize和-XX:MaxPermSize

-XX:PermSize分配非堆最小内存，默认为物理内存的1/64；-XX:MaxPermSize分配最大内存，默认为物理内存的1/4。



实际运行参数:

```bash
  -XX:+UseContainerSupport -XX:InitialRAMPercentage=60.0
  -XX:MaxRAMPercentage=60.0 -XX:MetaspaceSize=256M
  -XX:MaxMetaspaceSize=256M -XX:NewRatio=1 -XX:SurvivorRatio=4
  -XX:NativeMemoryTracking=summary -XX:+PrintGCDetails
  -XX:+PrintGCDateStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation 
  -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M 
  -Xloggc:/app/logs/gc-%t.log -XX:+HeapDumpOnOutOfMemoryError 
  -XX:HeapDumpPath=/app/logs/
```



```bash
# 1. 查找目标Java进程PID
jps -l

# 2. 使用jmap导出
jmap -dump:live,format=b,file=heap.hprof <PID>

# 3. 压缩文件（可选）
gzip heap.hprof


## jcmd <PID> GC.heap_dump <文件路径>
## curl -X POST http://localhost:8080/actuator/heapdump -o heapdump.hprof
```




## Spring

1. ApplicationContext: 直接通过注解ApplicationContext类型 或者 实现 ApplicationContextAware接口

2. 配置文件加载的优先级（由高到低）

   bootstrap.properties

   bootstrap.yml

   application.properties

   application.yml

3. 测试时指定参数

```java
@SpringBootTest(classes = ConfigurationExampleApplication.class, 
                properties = {"--mail.enabled=true","--spring.profiles.active=dev,extra"})
```

4. 注释中的链接 {@link SensitiveJsonSerializer}

5. @Import 注解

   src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

6. springboot2.6 + swagger, spring.mvc.pathmatch.strategy=*ant_path_matcher*
7. Lombok @RequiredArgsConstructor
8. HttpContext

```java
// 通过请求参数中获取 Request 对象；  
public void index(HttpServletRequest request) { }	

// 通过 RequestContextHolder 获取 Request 对象；
ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
HttpServletRequest request = servletRequestAttributes.getRequest();

// 通过自动注入获取 Request 对象;
@Autowired
private HttpServletRequest request; // 自动注入 request 对象
```



## Spring Cloud

1. 配置刷新 @RefreshScope

2. 服务注册 spring.cloud.nacos.discovery.register-enabled=false

3. mbp配置在naocs时, 本地控制日志输出

   --mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.slf4j.Slf4jImpl



