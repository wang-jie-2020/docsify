## POSTGRESQL



### Partition Table

通过运维工具进行数据的迁移:

```bash
nohup pg_dump -h localhost -p 15400 -U ess -d ess_test -t station_bank_hottone_source_bau -Fd -j 4 -f /backup/hot_bau/

nohup pg_restore -h localhost -p 15400 -U ess -d ess_test --data-only -Fd -j 4 /backup/hot_bau/
```



(1) 分区键必须包含在主键中

(2) 分区表不可支持EACH ROW触发器

```sql
create table ess.station_bank_hottone_source_bau
(
    id               bigint generated by default as identity,
    projectid        bigint,
   	.....
    primary key (id,projectid)
) partition by LIST (projectid);

alter table ess.station_bank_hottone_source_bau
    owner to ess;

select create_hottone_source_bau_partition_if_not_exists(1971024021432954882);


CREATE OR REPLACE FUNCTION create_hottone_source_bau_partition_if_not_exists(
  project_id BIGINT
) RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
BEGIN
    partition_name := 'station_bank_hottone_source_bau_' || project_id;

    -- 尝试创建分区，如果存在则忽略错误
    BEGIN
        EXECUTE format('
            CREATE TABLE %I PARTITION OF station_bank_hottone_source_bau
            FOR VALUES IN (%s)',
            partition_name, project_id
        );
    EXCEPTION WHEN duplicate_table THEN
        -- 分区已存在，正常流程
        NULL;
    END;
END;
$$ LANGUAGE plpgsql;
```

```sql
-- 检查索引
SELECT
    indexrelname AS index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    relname
FROM pg_stat_user_indexes
WHERE relname like 'station_bank_hottone_source_bau%'
ORDER BY pg_relation_size(indexrelid) DESC;

-- 检查分区表结构
SELECT
    pc.relname AS partition_name,
    pg_get_expr(pc.relpartbound, pc.oid) AS partition_condition,
    pg_size_pretty(pg_total_relation_size(pc.oid)) AS size,
    (SELECT COUNT(*) FROM pg_class pc2 WHERE pc2.oid = pc.oid)::BIGINT AS row_count
FROM pg_inherits pi
JOIN pg_class pc ON pc.oid = pi.inhrelid
WHERE pi.inhparent = 'station_bank_hottone_source_bau'::regclass
ORDER BY pc.relname;
```





